# Library 打包

## 前置准备

我们新建一个项目 `library`，在 src 目录下新建两个文件：

math.js :

```js
export function add (a, b) {
    return a + b;
}
export function minus (a, b) {
    return a - b;
}
export function multiply (a, b) {
    return a * b;
}
export function division (a, b) {
    return a / b;
}
```

str.js ；

```js
export function join (a, b) {
    return a + ' ' + b;
}
```

src 下新建入口文件 :

index.js :

```js
import * as math from './math';
import * as string from './str';

export default {
    math,
    string
}
```

下载安装 webpack :

```shell
$ yarn add webpack webpack-cli
```

配置 webpack.config.js :

```js
const path = require('path');

module.exports = {
    entry: {
        main: './src/index.js',
    },
    mode: 'production',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
    }
}
```

配置 package.json 打包命令 :

```json
"scripts": {
    "build": "webpack"
},
```

如此，我们就做好了一个项目了，接下来允许打包命令 `yarn run build`，就可以看到打包的结果了。

如果是普通项目，打包到此结束，可是如果是一个给其他人用的库的话，就不能直接结束。

## 兼容引入方法

考虑到其他人的用法：

```js
// ES6 module
import library form 'library';

// commonJS
const library = require('library');

// AMD
require(['library'], function() {
    
})

....
```

为了考虑这些问题，我们在导出中加一个配置项：

```js
output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        libraryTarget: 'umd'
    }
```

`libraryTarget` 就是用于指定库的挂载方式的，`umd` 表示通用模式，表示可以通过任何方式正确引用到我们的库文件。

下面要兼容 `<script>` 标签的引用：

```js
<script src='library.js'></script>

library.math
```

需要再加一个配置项：

```js
output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        libraryTarget: 'umd',
        library: 'library'
    }
```

新增一个全局变量 library，这个library 指向的就是 library，这样，他人通过 `<script>` 标签引入也是正常的。

如图：

![81223542](http://free-en-01.oss.tusy.xyz/2020128/1177-lq1zca.txs2m.png)

如果我们将代码改为：

```js
output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        library: 'library',
        libraryTarget: 'this'
    },
```

上面的也是在全局上挂载一个 library，这个 library 挂载在 this 上：

![81223543](http://free-en-01.oss.tusy.xyz/2020128/4606-sdfncw.edo6b.png)

`libraryTarget` 不止可以挂载到 this，还可以挂载到 global 和 windows，不过我们一般是直接使用 `umd` 这个通用的选项。

## 库引用库

[Externals 文档](https://webpack.js.org/configuration/externals/)

假设我们的库中引用了 loadsh 这个第三方库：

str.js :

```js
import _ from 'loadsh';

export function join (a, b) {
    return _.join([a, b], ' ');
}
```

因为我们这个库引用了 lodash，如果用户自己写业务代码的时候，也引用了 loadsh 这个库，就可能存在两个 loadsh 库代码。

为了解决这个问题，我们在 webpack.config.js 中设置一个配置项 :

```js
externals: ['loadsh'],
```

意思是忽略我们的库打包的时候，忽略 loadsh 这个库，当用户使用我们这个库的时候，让用户自己手动重新下载这个库。且用户手动下载后，任何情况下 loadsh 这个库名必须是 lodash。

Externals 还有其他配置，如 :

```js
externals : {
    lodash : {
      commonjs: 'lodash',
      amd: 'lodash',
      root: '_' // indicates global variable
    }
  },
```

上面的意思是当通过 commonJS 的方式引用 lodash 时，名字必须叫做 lodash，amd 同样。

root 的意思是当用户不通过 commonJS 或 amd 或 es6 module  方式引入，而是通过 <srcipt> 标签引入的时候，用户必须注册一个全局变量 `_`。

这个只是一个很简单的例子，实际上我们配置库打包时，还要考虑按需加载、tree shaking 之类的问题。

为了让别人更简单地使用我们的库，我们需要修改一下我们的 package.json :

```js
"main": "./dist/library.js",
```

也就是默认的主文件是我们打包好库后的入口文件。

之后我们就可以把这个项目发布到 npm 上面了。别人使用的时候就可以通过 `npm install [name]` 来使用了。

发布很简单，网上有教程，我们唯一需要注意的就是库名要唯一。

# PWA 打包配置

PWA（Progressive Web Application），作用就是当用户访问了一次页面后，如果服务器忽然挂掉了，用户再次访问这个网页，可以从缓存中 加载它。

即官网所说的：当用户打开我们站点时（从桌面 icon 或者从浏览器），通过 Service Worker 能够让用户在网络条件很差的情况下也能瞬间加载并且展现。

在 webpack 中，可以使用一个名为 `workbox-webpack-plugin` 的插件很方便地使用 PWA。

先下载这个插件

```shell
$ yarn add workbox-webpack-plugin
```

这个插件只使用在开发环境中，所以去 webpack.prod.js 中配置（这里使用的是 Hello Webpack 这个项目）：

```js
const workboxWebpackPlugin = require('workbox-webpack-plugin');
```

```js
plugins: [
        new MiniCssExtractPlugin({
            filename: '[name].css',
            chunkFilename: '[id].css',
          }),
          new workboxWebpackPlugin.GenerateSW({
              clientsClaim: true,
              skipWaiting: true
          })
    ],
```

打包成功，多出两个文件 service-worker.js 和 precache-mainfest…….js :

![81223544](http://free-en-01.oss.tusy.xyz/2020128/16772-3slogs.3xtrb.png)

现在项目就支持 PWA，但是要使用，还需要我们在我们的业务代码中写入如下内容：

src/index.js :

```js
....

if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
            .then(registration => {
                console.log('service-worker register');
            }).catch(error => {
                console.log('serviec-work register error');
            })
    })
}
```

因为没有服务器，所以我们安装一个 http-server 来模拟：

```shell
$ yarn add -D http-server
```

配置启动命令：

```json
"scripts": {
    "dev": "webpack-dev-server --config ./build/webpack.dev.js",
    "dev-build": "webpack --profile --json > stats.json --config ./build/webpack.dev.js",
    "build": "webpack --config ./build/webpack.prod.js",
    "start": "http-server dist"
  },
```

打包，运行，可以看到页面正常显示，此时如果我们关闭我们的服务器，刷新，页面依然正常显示。

# TypeScript 打包配置

【代码所在】

代码位于对应目录的 type-script 文件夹下。

【内容】

TypeScript 最大的优势就是规范我们的代码。[TypeScript 官网](https://www.typescriptlang.org/)

webpack 官方的 typescript loader 是：[ts-loader](https://webpack.js.org/guides/typescript/)

```shell
$ npm install --save-dev typescript ts-loader
```

然后根据官网配置即可，需要注意的是，我们需要一个配置一个 **tsconfig.json** 文件，官网也有。

tsconfig.json :

```js
{
    "compilerOptions": {
        "outDir": "./dist/",
        "noImplicitAny": true,
        "module": "es6",
        "target": "es5",
        "jsx": "react",
        "allowJs": true
    }
}
```

- outDir：表示打包后的文件放到项目的 dist 文件中
- module：表示模块引用方式
- target：表示 tsx 语法最终会被打包成什么形式
- allowJS：表示允许引入 js 文件

我们在 src 下面新建一个 index.tsx 文件：

```tsx
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "hello," + this.greeting;
    }
}

let greeter = new Greeter("word");

let button = document.createElement('button');
button.textContent = "Say Hello"
button.addEventListener('click', () => {
    alert(greeter.greet());
})

document.body.appendChild(button);
```

执行打包命令，一切正常。



