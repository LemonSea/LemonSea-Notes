# Library 打包

## 前置准备

我们新建一个项目 `library`，在 src 目录下新建两个文件：

math.js :

```js
export function add (a, b) {
    return a + b;
}
export function minus (a, b) {
    return a - b;
}
export function multiply (a, b) {
    return a * b;
}
export function division (a, b) {
    return a / b;
}
```

str.js ；

```js
export function join (a, b) {
    return a + ' ' + b;
}
```

src 下新建入口文件 :

index.js :

```js
import * as math from './math';
import * as string from './str';

export default {
    math,
    string
}
```

下载安装 webpack :

```shell
$ yarn add webpack webpack-cli
```

配置 webpack.config.js :

```js
const path = require('path');

module.exports = {
    entry: {
        main: './src/index.js',
    },
    mode: 'production',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
    }
}
```

配置 package.json 打包命令 :

```json
"scripts": {
    "build": "webpack"
},
```

如此，我们就做好了一个项目了，接下来允许打包命令 `yarn run build`，就可以看到打包的结果了。

如果是普通项目，打包到此结束，可是如果是一个给其他人用的库的话，就不能直接结束。

## 兼容引入方法

考虑到其他人的用法：

```js
// ES6 module
import library form 'library';

// commonJS
const library = require('library');

// AMD
require(['library'], function() {
    
})

....
```

为了考虑这些问题，我们在导出中加一个配置项：

```js
output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        libraryTarget: 'umd'
    }
```

`libraryTarget` 就是用于指定库的挂载方式的，`umd` 表示通用模式，表示可以通过任何方式正确引用到我们的库文件。

下面要兼容 `<script>` 标签的引用：

```js
<script src='library.js'></script>

library.math
```

需要再加一个配置项：

```js
output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        libraryTarget: 'umd',
        library: 'library'
    }
```

新增一个全局变量 library，这个library 指向的就是 library，这样，他人通过 `<script>` 标签引入也是正常的。

如图：

![81223542](http://free-en-01.oss.tusy.xyz/2020128/1177-lq1zca.txs2m.png)

如果我们将代码改为：

```js
output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        library: 'library',
        libraryTarget: 'this'
    },
```

上面的也是在全局上挂载一个 library，这个 library 挂载在 this 上：

![81223543](http://free-en-01.oss.tusy.xyz/2020128/4606-sdfncw.edo6b.png)

`libraryTarget` 不止可以挂载到 this，还可以挂载到 global 和 windows，不过我们一般是直接使用 `umd` 这个通用的选项。

## 库引用库

[Externals 文档](https://webpack.js.org/configuration/externals/)

假设我们的库中引用了 loadsh 这个第三方库：

str.js :

```js
import _ from 'loadsh';

export function join (a, b) {
    return _.join([a, b], ' ');
}
```

因为我们这个库引用了 lodash，如果用户自己写业务代码的时候，也引用了 loadsh 这个库，就可能存在两个 loadsh 库代码。

为了解决这个问题，我们在 webpack.config.js 中设置一个配置项 :

```js
externals: ['loadsh'],
```

意思是忽略我们的库打包的时候，忽略 loadsh 这个库，当用户使用我们这个库的时候，让用户自己手动重新下载这个库。且用户手动下载后，任何情况下 loadsh 这个库名必须是 lodash。

Externals 还有其他配置，如 :

```js
externals : {
    lodash : {
      commonjs: 'lodash',
      amd: 'lodash',
      root: '_' // indicates global variable
    }
  },
```

上面的意思是当通过 commonJS 的方式引用 lodash 时，名字必须叫做 lodash，amd 同样。

root 的意思是当用户不通过 commonJS 或 amd 或 es6 module  方式引入，而是通过 <srcipt> 标签引入的时候，用户必须注册一个全局变量 `_`。

这个只是一个很简单的例子，实际上我们配置库打包时，还要考虑按需加载、tree shaking 之类的问题。

为了让别人更简单地使用我们的库，我们需要修改一下我们的 package.json :

```js
"main": "./dist/library.js",
```

也就是默认的主文件是我们打包好库后的入口文件。

之后我们就可以把这个项目发布到 npm 上面了。别人使用的时候就可以通过 `npm install [name]` 来使用了。

发布很简单，网上有教程，我们唯一需要注意的就是库名要唯一。

# PWA 打包配置

PWA（Progressive Web Application），作用就是当用户访问了一次页面后，如果服务器忽然挂掉了，用户再次访问这个网页，可以从缓存中 加载它。

即官网所说的：当用户打开我们站点时（从桌面 icon 或者从浏览器），通过 Service Worker 能够让用户在网络条件很差的情况下也能瞬间加载并且展现。

在 webpack 中，可以使用一个名为 `workbox-webpack-plugin` 的插件很方便地使用 PWA。

先下载这个插件

```shell
$ yarn add workbox-webpack-plugin
```

这个插件只使用在开发环境中，所以去 webpack.prod.js 中配置（这里使用的是 Hello Webpack 这个项目）：

```js
const workboxWebpackPlugin = require('workbox-webpack-plugin');
```

```js
plugins: [
        new MiniCssExtractPlugin({
            filename: '[name].css',
            chunkFilename: '[id].css',
          }),
          new workboxWebpackPlugin.GenerateSW({
              clientsClaim: true,
              skipWaiting: true
          })
    ],
```

打包成功，多出两个文件 service-worker.js 和 precache-mainfest…….js :

![81223544](http://free-en-01.oss.tusy.xyz/2020128/16772-3slogs.3xtrb.png)

现在项目就支持 PWA，但是要使用，还需要我们在我们的业务代码中写入如下内容：

src/index.js :

```js
....

if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
            .then(registration => {
                console.log('service-worker register');
            }).catch(error => {
                console.log('serviec-work register error');
            })
    })
}
```

因为没有服务器，所以我们安装一个 http-server 来模拟：

```shell
$ yarn add -D http-server
```

配置启动命令：

```json
"scripts": {
    "dev": "webpack-dev-server --config ./build/webpack.dev.js",
    "dev-build": "webpack --profile --json > stats.json --config ./build/webpack.dev.js",
    "build": "webpack --config ./build/webpack.prod.js",
    "start": "http-server dist"
  },
```

打包，运行，可以看到页面正常显示，此时如果我们关闭我们的服务器，刷新，页面依然正常显示。

# TypeScript 打包配置

【代码所在】

代码位于对应目录的 type-script 文件夹下。

【内容】

TypeScript 最大的优势就是规范我们的代码。[TypeScript 官网](https://www.typescriptlang.org/)

webpack 官方的 typescript loader 是：[ts-loader](https://webpack.js.org/guides/typescript/)

```shell
$ npm install --save-dev typescript ts-loader
```

然后根据官网配置即可，需要注意的是，我们需要一个配置一个 **tsconfig.json** 文件，官网也有。

tsconfig.json :

```js
{
    "compilerOptions": {
        "outDir": "./dist/",
        "noImplicitAny": true,
        "module": "es6",
        "target": "es5",
        "jsx": "react",
        "allowJs": true
    }
}
```

- outDir：表示打包后的文件放到项目的 dist 文件中
- module：表示模块引用方式
- target：表示 tsx 语法最终会被打包成什么形式
- allowJS：表示允许引入 js 文件

我们在 src 下面新建一个 index.ts 文件：

```tsx
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "hello," + this.greeting;
    }
}

let greeter = new Greeter("word");

let button = document.createElement('button');
button.textContent = "Say Hello"
button.addEventListener('click', () => {
    alert(greeter.greet());
})

document.body.appendChild(button);
```

执行打包命令，一切正常。

如果我们想要在 ts 中使用 lodash，除了 lodash 外，还需要安装对应的  @types/lodash：

```shell
$ yarn add -D lodash 
```

```shell
$ npm install --save @types/lodash
```

而且在 TypeScript 中的引用规则也要有变化：

```shell
$ import * as _ from "lodash";
```

同样的，如果是 jQuery，也需要对应的  @types/jquery。

要找到支持 ts 的对应的文件 ，可以在 [TypeSearch](https://microsoft.github.io/TypeSearch/) 中查找。

如查找 jQuery：

![81223545](http://free-en-01.oss.tusy.xyz/2020128/16772-1ujwnl4.j1ezi.png)

## 踩坑

使用第三方库时，先安装库本身，在安装对应库的 ts 支持。

# webpackServer 实现请求转发

在 webapckServer 中，可以通过 [devServer](https://webpack.js.org/configuration/dev-server/) 的 proxy 来进行请求的转发。

webpack.config.js :

```js
module.exports = {
  //...
  devServer: {
    proxy: {
      '/api': 'http://localhost:3000'
    }
  }
};
```

这个配置项，会让我们在请求 /api 这个接口的时候，走 localhost:3000 这个服务器去请求内容。

## pathRewrite

除了服务器，还可以进行接口的的转发：

```js
module.exports = {
  //...
  devServer: {
    proxy: {
      '/react/api': {
          target: 'http://www.dell-lee.com',
          pathRewrite: {
              'demo.json': 'header.json'
          }
      }
    }
  }
};
```

上面的代码意思是，当我们请求 `/react/api/header.json` 这个接口的时候，我们会转发到 `http://www.dell-lee.com/react/api/demo.json` 这个接口去拿数据。

常见的应用场景在于，当后端接口还没有调好，我们要开发对应的前端页面的时候，就可以利用 `pathRewrite` 这个配置项转发到我们的模拟接口上，而 axios 的请求地址还是 `header.json` 不用更改。这样就避免我们后期去代码中改接口。

如我们在 index.js 中写如下代码：

```js
import 'regenerator-runtime/runtime';

import React, { Component } from 'react';
import ReactDom from 'react-dom';
import axios from 'axios';

class App extends Component {
    constructor(props) {
        super(props);
        this.state = {
            data: 'null'
        };
    }

    componentDidMount() {
        axios.get('/react/api/demo.json')
            .then(res => {
                const data = res.data.data;
                console.log(data)
                this.setState({data: JSON.stringify(data)});
            })
            .catch(err => {
                console.error(err);
            })
    }

    render() {
        return (
            <div>
                {
                    this.state.data
                }
            </div>
        )
    }
}

ReactDom.render(<App />, document.getElementById('root'));

```

这里我们在 react 的 componentDidMount 这个生命周期的时候，发送了一次 ajax 请求，请求的接口是 /react/api/demo.json，按理说，应该回去 `localhost:9000/react/api/demo.json` 这个接口拿数据，但是我们在 devServer 这里进行了配置：

```js
devServer: {
        port: 9000,
        proxy: {
            '/react/api': {
                target: 'http://www.dell-lee.com',
                pathRewrite: {
                    'demo.json': 'header.json'
                }
            }
          }       
    },
```

这就让我们对于 `/react/api`  这个接口的请求转发到了 http://www.dell-lee.com 这个服务器上，且如果我们调用的是 `demo.json`，那么还会自动获取 `header.json` 上的内容发给我们。

如图，请求的明明是 `http://localhost:9000/react/api/demo.json` 这个接口，但是却能正常拿到数据，原因就在于我们的实际请求转到了 `http://www.dell-lee.com/react/api/header.json` 这个接口上。

![81223546](http://free-en-01.oss.tusy.xyz/2020128/4606-pbdrkw.3xgms.png)

需要注意的是，我们这里的 devServer 的配置的是开发环境的 webpack.config.js，而不是生产环境的，所以一旦我们的项目上线，就不会有转发了，而是请求我们真正的服务器。

## https

上面的请求实现的是 http，当我们 proxy 的是 https 的时候，要在 devServer 中配置 `secure: false`。

```js
proxy: {
    '/react/api': {
        target: 'http://www.dell-lee.com',
        secure: false,
        pathRewrite: {
            'demo.json': 'header.json'
        }
    }
}  
```

## bypass

该配置项是拦截：

```js
module.exports = {
  //...
  devServer: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        bypass: function(req, res, proxyOptions) {
          if (req.headers.accept.indexOf('html') !== -1) {
            console.log('Skipping proxy for browser request.');
            return '/index.html';
          }
        }
      }
    }
  }
};
```

当发现请求的是 html 时，直接拦截并返回 `/index.html` 页面。

## context

是同时对应多个：

```js
module.exports = {
  //...
  devServer: {
    proxy: [{
      context: ['/auth', '/api'],
      target: 'http://localhost:3000',
    }]
  }
};
```

当请求 `/auth` 和 `/api` 的时候，都会转发。

## index

当我们做主页的转发时，要配置这个参数才能生效

```javascript
module.exports = {
  //...
  devServer: {
    index: '', // specify to enable root proxying
    host: '...',
    contentBase: '...',
    proxy: {
      context: () => true,
      target: 'http://localhost:1234'
    }
  }
};
```

## changeOrigin

为了绕过爬虫，有的网页有爬虫限制，通过 `changeOrigin:true` 可以解决 :

```js
module.exports = {
  //...
  devServer: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true
      }
    }
  }
};
```

建议始终加上。

更多配置查看官方文档。

devServer 的底层是  [webpack-dev-middleware](https://github.com/webpack/webpack-dev-middleware)。我们可以直接看 这里也行，可配置项非常非常地多。

# webpackServer  解决单页面路由问题（react）

这里以 react 的路由 react-router-dom 为例，安装路由：

```shell
$ yarn add react-router-dom
```

## 写页面

list.js :

```js
import React, { Component } from 'react';

class List extends Component {
    render() {
        return (
            <div>
                ListPage
            </div>
        )
    }
}

export default List;
```

home.js :

```js
import React, { Component } from 'react';

class Home extends Component {
    render() {
        return (
            <div>
                Home Page
            </div>
        )
    }
}

export default Home;

```

## 配路由

index.js :

```js
import 'regenerator-runtime/runtime';

import React, { Component } from 'react';
import ReactDom from 'react-dom';
import axios from 'axios';
import { BrowserRouter, Route } from 'react-router-dom';


import Home from './home';
import List from './list';

class App extends Component {
    constructor(props) {
        super(props);
        this.state = {
            data: 'null'
        };
    }

    componentDidMount() {
        axios.get('/react/api/demo.json')
            .then(res => {
                const data = res.data.data;
                console.log(data)
                this.setState({ data: JSON.stringify(data) });
            })
            .catch(err => {
                console.error(err);
            })
    }

    render() {
        return (
            <div>
                <div>
                    {
                        this.state.data
                    }
                </div>
                <BrowserRouter>
                    <Route path='/' exact component={Home} />
                    <Route path='/list' component={List} />
                </BrowserRouter>
            </div>
        )
    }
}

ReactDom.render(<App />, document.getElementById('root'));

```

此时如果使用 `'/' `页面是没有问题的，但是如果跳转 `'/list'` 页面，就会提示页面不存在，原因是打包的文件中没有 list 页面。

要解决这个，就需要在 devServer 中配置 [devServer.historyApiFallback](https://webpack.js.org/configuration/dev-server/#devserverhistoryapifallback) :

```js
module.exports = {
  //...
  devServer: {
    historyApiFallback: true
  }
};
```

配好后，即可正常访问。

## 其他配置

```js
module.exports = {
  //...
  devServer: {
    historyApiFallback: {
      rewrites: [
        { from: /^\/$/, to: '/views/landing.html' },
        { from: /^\/subpage/, to: '/views/subpage.html' },
        { from: /./, to: '/views/404.html' }
      ]
    }
  }
};
```

上面的意思是，当访问 `/subpage` 开头的内容，就展示 `/views/subpage.html`。

## 底层实现

[connect-history-api-fallback](https://github.com/bripkens/connect-history-api-fallback)

## 踩坑

这里是的 `historyApiFallback` 是开发环境的配置，一旦上线就会报错，这里就需要后端去 Apache 之类的服务器上做和 `historyApiFallback` 一样的配置了。

# EsLint 在 webpack 中的配置

EsLint 是一个代码语法约束工具。

安装：

```shell
$ yarn add eslint -D
```

生成约束文件：

```shell
$ npx eslint --init
```





