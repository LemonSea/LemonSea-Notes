# Library 打包

## 前置准备

我们新建一个项目 `library`，在 src 目录下新建两个文件：

math.js :

```js
export function add (a, b) {
    return a + b;
}
export function minus (a, b) {
    return a - b;
}
export function multiply (a, b) {
    return a * b;
}
export function division (a, b) {
    return a / b;
}
```

str.js ；

```js
export function join (a, b) {
    return a + ' ' + b;
}
```

src 下新建入口文件 :

index.js :

```js
import * as math from './math';
import * as string from './str';

export default {
    math,
    string
}
```

下载安装 webpack :

```shell
$ yarn add webpack webpack-cli
```

配置 webpack.config.js :

```js
const path = require('path');

module.exports = {
    entry: {
        main: './src/index.js',
    },
    mode: 'production',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
    }
}
```

配置 package.json 打包命令 :

```json
"scripts": {
    "build": "webpack"
},
```

如此，我们就做好了一个项目了，接下来允许打包命令 `yarn run build`，就可以看到打包的结果了。

如果是普通项目，打包到此结束，可是如果是一个给其他人用的库的话，就不能直接结束。

## 兼容引入方法

考虑到其他人的用法：

```js
// ES6 module
import library form 'library';

// commonJS
const library = require('library');

// AMD
require(['library'], function() {
    
})

....
```

为了考虑这些问题，我们在导出中加一个配置项：

```js
output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        libraryTarget: 'umd'
    }
```

`libraryTarget` 就是用于指定库的挂载方式的，`umd` 表示通用模式，表示可以通过任何方式正确引用到我们的库文件。

下面要兼容 `<script>` 标签的引用：

```js
<script src='library.js'></script>

library.math
```

需要再加一个配置项：

```js
output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        libraryTarget: 'umd',
        library: 'library'
    }
```

新增一个全局变量 library，这个library 指向的就是 library，这样，他人通过 `<script>` 标签引入也是正常的。

如图：

![81223542](http://free-en-01.oss.tusy.xyz/2020128/1177-lq1zca.txs2m.png)

如果我们将代码改为：

```js
output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        library: 'library',
        libraryTarget: 'this'
    },
```

上面的也是在全局上挂载一个 library，这个 library 挂载在 this 上：

![81223543](http://free-en-01.oss.tusy.xyz/2020128/4606-sdfncw.edo6b.png)

`libraryTarget` 不止可以挂载到 this，还可以挂载到 global 和 windows，不过我们一般是直接使用 `umd` 这个通用的选项。

## 库引用库

[Externals 文档](https://webpack.js.org/configuration/externals/)

假设我们的库中引用了 loadsh 这个第三方库：

str.js :

```js
import _ from 'loadsh';

export function join (a, b) {
    return _.join([a, b], ' ');
}
```

因为我们这个库引用了 lodash，如果用户自己写业务代码的时候，也引用了 loadsh 这个库，就可能存在两个 loadsh 库代码。

为了解决这个问题，我们在 webpack.config.js 中设置一个配置项 :

```js
externals: ['loadsh'],
```

意思是忽略我们的库打包的时候，忽略 loadsh 这个库，当用户使用我们这个库的时候，让用户自己手动重新下载这个库。且用户手动下载后，任何情况下 loadsh 这个库名必须是 lodash。

Externals 还有其他配置，如 :

```js
externals : {
    lodash : {
      commonjs: 'lodash',
      amd: 'lodash',
      root: '_' // indicates global variable
    }
  },
```

上面的意思是当通过 commonJS 的方式引用 lodash 时，名字必须叫做 lodash，amd 同样。

root 的意思是当用户不通过 commonJS 或 amd 或 es6 module  方式引入，而是通过 <srcipt> 标签引入的时候，用户必须注册一个全局变量 `_`。

这个只是一个很简单的例子，实际上我们配置库打包时，还要考虑按需加载、tree shaking 之类的问题。

为了让别人更简单地使用我们的库，我们需要修改一下我们的 package.json :

```js
"main": "./dist/library.js",
```

也就是默认的主文件是我们打包好库后的入口文件。

之后我们就可以把这个项目发布到 npm 上面了。别人使用的时候就可以通过 `npm install [name]` 来使用了。

发布很简单，网上有教程，我们唯一需要注意的就是库名要唯一。

# PWA 打包配置

PWA（Progressive Web Application），作用就是当用户访问了一次页面后，如果服务器忽然挂掉了，用户再次访问这个网页，可以从缓存中 加载它。

即官网所说的：当用户打开我们站点时（从桌面 icon 或者从浏览器），通过 Service Worker 能够让用户在网络条件很差的情况下也能瞬间加载并且展现。