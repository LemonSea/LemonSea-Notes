# Tree Shaking

## 前期配置

这里用的是核心概念里的配置，在 src 目录下创建一个 main.js 文件：

main.js:

```js
export const add = (a, b) => {
    console.log(a + b);
}

export const minus = (a, b) => {
    console.log(a - b);
}
```

修改 index.js，我们导入 add 方法并使用：

```js
import { add } from './main';

add(1, 2);
```

使用 `npx webpack` 命令进行打包，页面正常运行输出。

观察打包完成的输出内容可以看到 main.js 的大小很小，说明的确是按需加载的：

![81223513](http://free-en-01.oss.tusy.xyz/2020125/16772-1uowaun.tns7.png)

最好看一下 main.js 中对应的文件，发现有 `/*! exports provided: add, minus */` 的内容：

![81223514](http://free-en-01.oss.tusy.xyz/2020125/4606-merscc.8eoh.png)

看 eval 中的内容也可以看到。这样就有一个问题，我们只需要 add 方法的内容，可是打包的时候连同 minus 的内容也打包了，这是恨没有必要的，最理想的方法是，我们引入什么，就打包什么，这就需要 `tree shaking`，该概念在 webpack@2.0 后有实现。

## 使用

**Tree Shaking 只支持 ES 的模块导入方式：即 import 的导入和 export 的导出。如果使用 commonJS 就不行。**

原因是 **ES Module** 的导入方式是**静态**的，而 **CommonJS**  的导入方式是**动态**的。

我们当前是开发环境（`mode: 'development'`），要启用 Tree Shaking 需要在 webpack.config.js 中加入以下内容：

```js
optimization: {
    usedExports: true
}
```

该内容可以加载 plugins 后面。

配置 package.json，加上 `"sideEffects": false,`：

```json
{
  "scripts": {
    "start": "webpack-dev-server"
  },
  "sideEffects": false,
  "dependencies": {
      ....
  },
  "devDependencies": {
      ....
  }
}
```

这个命令的意思就是让我们设置不会因为无导出而被忽略的未打包的文件。

如在以前的代码中，我们使用 `@babel/polly-fill` 这种包使用，就要把这个包加到这里来：`"sideEffects": ["@babel/polly-fill"]`。

或者是把 css 文件加到这里：

```js
{
  "scripts": {
    "start": "webpack-dev-server"
  },
  "sideEffects": ["*.css"],
  "dependencies": {
      ....
  },
  "devDependencies": {
      ....
  }
}
```

此时打包，就多了一行 `/*! exports used: add */` ：

![81223515](http://free-en-01.oss.tusy.xyz/2020125/4606-4aicgk.lcj2l.png)

此时模块已经生效，之所以在 eval 中还能找到 minus 的内容，是因为我们是在 `mode: 'development'` 环境下，默认不会去除掉而是提示，以方便我们进行调试。我们在生产环境中：

```js
mode: 'production',
devtool: 'cheap-module-source-map',
```

就会自动去除，且生产环境会自动配置 tree shaking，我们都不需要写

```js
optimization: {
    usedExports: true
}
```

配置项，但是 package 的 `sideEffects` 需要配置。

# development和 Production 模式的区别

- development
  - 开发环境
  - sourceMap 是很完整的，可以帮我们快速定位问题。
  - 代码不需要压缩。
  - 需要手动开启 usedExports。

- Production 时
  - 生产环境
  - sourceMap 就不是那么重要了，所以内容可能更加简洁一些。
  - 代码会压缩。
  - 自动开启 usedExports。

如果开发转生产，webpack.config.js 内的内容就要频繁变动，为了让我们方便一些，可以重命名现在的 webpack.config.js 为 webpack.dev.js，表明这是开发环境下使用的 webpack 配置文件。然后新建一个 webpack.prod.js，表明是生产环境下使用的 webpack 配置文件。

复制开发环境的代码到生产环境的配置文件中，并做相应的修改：

- mode 设置
- devtool 设置
- 删除 devServer（因为生产环境只需要打包就行了）
- plugins 中去除 HMR 插件
- optimization 中去除 usedExports: true

现在，我们就有了线上版本的 webpack.prod.js 文件。

然后修改 package.json :

```json
"scripts": {
    "dev": "webpack-dev-server --config webpack.dev.js",
    "build": "webpack --config webpack.prod.js"
},
```

上面定义了开会环境下的命令为 dev，使用 webpackDevServer，对应的配置文件是 webpack.dev.js。生产环境下的打包命令为 build，使用 webpack 打包，对应的配置文件是 webpack.prod.js。

开发环境下还可以关闭 hotOnly

```js
devServer: {
        contentBase: './dist',
        open: true,
        proxy: {
            './api': 'http://localhost:3000'
        },
        hot: true,  // 开启 HMR 功能
        // hotOnly: true  // 即使 HMR 功能未成功开启，也不让浏览器自动刷新
    },
```

这让我们的浏览器实时响应变化而不必使用下面的代码：

```js
if (module.hot) {
    module.hot.accept('./number.js', () => {
        // 更新后，先移除原有的 number 内容，再重新执行 number 内容。
        document.body.removeChild(document.getElementById('number'));
        number();
    })
}
```

