# 如何编写一个 Loader

当我们在 webpack 中打包一种类型文件，loader 就会发生作用。

先新建一个 make-loader 项目，在初始化和简单配置项目的 webpack.config.js，然后新建一个 loaders 文件夹，一个 replaceLoader.js 文件。

## 最简单的 loader

我们常说的 loader 就是一个函数：

```js
module.exports = function(source) {
  return source.replace('dell', 'dellLee');
}	
```

loader 的 function 一定是声明式的 function，不能是箭头函数，因为我们要使用 function 里面的 this。

在 webapck.config.js 中使用：

```js
const path = require('path');

module.exports = {
  mode: 'development',
  entry: {
      main: './src/index.js'
  },
    module: {
      rules: [
      {
        test: /\.js$/,
        use: [path.resolve(__dirname, './loaders/replaceLoader.js')]
      }    
    ]
  },
  output: {
      path: path.resolve(__dirname, 'dist'),
      filename: '[name].js'
  }
}
```

打包完成，就可以 看见 dell 已经被替换了：

![81223556](http://free-en-01.oss.tusy.xyz/2020129/1177-1qkjonf.kzx.png)

上面我们就实现了一个最简单的 loader 并使用它。

## 使用 loader 的 option

我们在 webpack.config.js 中使用 loader 时，经常使用 option 选项。我们也来实现一下这个选项：

webpack.config.js :

```js
module: {
    rules: [
        {
            test: /\.js$/,
            use: [
                {
                    loader: path.resolve(__dirname, './loaders/replaceLoader.js'),
                    options: {
                        name: 'lee'
                    }
                }                    
            ]
        }
    ]
},
```

options 的内容会传递给我们的 loader，而我们的 loader 是通过 **this** 进行接收的而不是通过 **参数** 进行接收的。（这就是我们不能使用箭头函数的原因），可以通过 **this.query** 来查看参数：

replaceLoader.js :

```js
module.exports = function(source) {
  console.log(this.query)
  return source.replace('dell', 'dellLee');
}
```

如图：![81223557](http://free-en-01.oss.tusy.xyz/2020129/4606-rxpe3b.df2v.png)

官方推荐了一个插件来帮助我们分析获取 options 传递的内容： [loader-utils](https://github.com/webpack/loader-utils#getoptions)

## 使用 loader-utils（获取 options）

 [loader-utils](https://github.com/webpack/loader-utils#getoptions)

安装：

```shell
$ yarn add -D loader-utils
```

使用：

replaceLoader.js :

```js
const loaderUtils = require('loader-utils');

module.exports = function(source) {
  const options = loaderUtils.getOptions(this);
  console.log(options)
  return source.replace('dell', 'dellLee');
}
```

如图：![81223558](http://free-en-01.oss.tusy.xyz/2020129/1177-rttmq.i0y2zf.png)

## 使用 this.callback

我们前面的 loader 通过 return 回了一个内容，而当我们想要返回很多额外的东西的时候，就可以使用 this.callback ，其参数配置：

```js
this.callback(
  err: Error | null,
  content: string | Buffer,
  sourceMap?: SourceMap,
  meta?: any
);
```

1. The first argument must be an `Error` or `null`
2. The second argument is a `string` or a [`Buffer`](https://nodejs.org/api/buffer.html).
3. Optional: The third argument must be a source map that is parsable by [this module](https://github.com/mozilla/source-map).
4. Optional: The fourth option, ignored by webpack, can be anything (e.g. some metadata).

在 replaceLoader 中使用：

```js
const loaderUtils = require('loader-utils');

module.exports = function(source) {
  const options = loaderUtils.getOptions(this);
  console.log(options)
  const result = source.replace('dell', options.name);;
  this.callback(null, result)
}
```

此时的 this.cacllback 等同于 return。

## loader 中的异步操作（this.async）

replaceLoader.js :

```js
const loaderUtils = require('loader-utils');

module.exports = function (source) {
  const options = loaderUtils.getOptions(this);
  setTimeout(() => {
    const result = source.replace('dell', options.name);;
    this.callback(null, result)
  }, 1000);
}
```

上面的写法我们通过定时器，在 1s 后返回，就是一个典型的异步操作，此时打包，肯定报错。

如果想要使用这种，就需要另一个操作：this.async

replaceLoader.js :

```js
const loaderUtils = require('loader-utils');

module.exports = function (source) {
  const options = loaderUtils.getOptions(this);
  this.callback = this.async();
  setTimeout(() => {
    const result = source.replace('dell', options.name);;
    this.callback(null, result)
  }, 1000);
}
```

上面通过 `this.callback = this.async()` 声明了 `this.callback` 中含有异步操作，于是我们就可以这样使用异步了。

## 注意

loader 的使用顺序是从上到下，从右到左。





