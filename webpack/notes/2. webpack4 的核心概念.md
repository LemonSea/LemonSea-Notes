# webpack 官网食用指南

webpack API、插件官网就有很多，私人开发的更多，完全记住是不可能的，所以我们的使用方法就是遇到问题的时候要会查文档，要会问前辈。

# webpack 打包图片配置

webpack 默认能够打包 js，但是不能打包图片，要打包图片，需要使用插件：`file-loader`，可在官网查看，[webpack 官方文档](https://www.webpackjs.com/loaders/file-loader/)

【安装】

```shell
$ npm install --save-dev file-loader
```

还是上一章的案例，在 `img` 文件夹下放入一个图片，在 `index.js` 导入：

```js
import Header from './header';
import Sidebar from './sidebar';
import Content from './content';
import avater from '../img/png.png';

new Header();
new Sidebar();
new Content();
```

此时执行 `yarn run bundle` 会报错，因为 webpack 默认不能打包图片格式，我们需要自己配置：

webpack.config.js :

```js
const path = require('path')

module.exports = {
    mode: 'development',
    entry: {
    	main: './index.js'
    },
    module: {
        rules: [{
            test: /\.png$/,
            use: {
                loader: 'file-loader'
            }
        }]
    },
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist')
    }
}
```

我们在上面使用一个`file-loader` 插件来打包我们的图片，现在执行打包指令就不会出错 。

![81223485](http://free-en-01.oss.tusy.xyz/2020123/1177-stx90t.13vr.png)

成功后会发现 `dist` 目录下有两个文件，一个是我们的 js 文件打包，一个是我们的图片打包地文件，依然是一个图片。

![81223486](http://free-en-01.oss.tusy.xyz/2020123/4606-fyorgi.grdvl.png)

如果在 `index.js` 中 `console.log(avater)`，执行 `bundle.js` 文件，会输出图片的名字。

# webpack 打包机制

webpack 在打包的时候，默认能够打包 js 文件，当打包到我们链接的图片格式时，webpack 默认无法打包，就会去 webpack.config.js 中寻找帮助，我们在 webpack.config.js 中定义了文件 png 格式打包时使用 file-loader 这个插件，webpack 使用这个插件就能打包图片了。

**file-loader 可以打包很多文件（jpg，txt，excel 等）**

我们之所以知道 webpack 能够用 file-loader 打包图片，是官方文档推荐的，所以官方文档很重要！

# 什么是 loader

loader 就是 webpack 的打包机制，webpack 不知道如何打包时，就回去求助于 loader，以能够正确打包。

# 图片打包实践

调整目录结构，将 index.html 放入 dist 文件夹中（这里是为了打包后能找到图片，如果不这样，在下面的图片地址那里就要做一些修改）

index.js :

```js
import avatar from './png.png';

let img = new Image();
img.src =avatar;

let root = document.getElementById('root');
root.append(img);
```

打开 index.html 文件，可以看到正确显示的图片。

# Loader 打包静态资源（图片）

## file-loader

[file-loader 官方文档](https://www.webpackjs.com/loaders/file-loader/#placeholders)

现在我们打包后，图片名称改变了，如果我们希望图片名字不变，就要做一些配置：

webpack.config.js :

```js
const path = require('path')

module.exports = {
    mode: 'development',
    entry: {
    	main: './src/index.js'
    },
    module: {
        rules: [{
            test: /\.png$/,
            use: {
                loader: 'file-loader',
                options: {
                    // placeholders（占位符）
                    name: '[name].[ext]'
                }
            }
        }]
    },
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist')
    }
}
```

这里我们在 file-loader 配置选项中使用了一个占位符，来规定打包后文件的名字。[官方文档](https://www.webpackjs.com/loaders/file-loader/#placeholders)

除了指定名称外，还可以指定其他的很多东西，如图片打包路径：

```js
options: {
    // placeholders
    name: '[name].[ext]',
        outputPath: 'images/'
}
```

这里规定了图片的输出路径为 `dist/image`。所以，当我们需要配置一些东西的时候，一定要去查看对应的[官方文档](https://www.webpackjs.com/loaders/file-loader/#placeholders)。

## url-loader

[url-loader 官方文档](https://www.webpackjs.com/loaders/url-loader/)

将打包规则替换为 url-loader ：

```js
module: {
    rules: [{
        test: /\.(png|jpg|gif)$/,
        use: {
            loader: 'url-loader',
            options: {
                name: '[name]_[hash].[ext]',
                outputPath: 'images/'
            }
        }
    }]
},
```

执行命令后，会发现打包完成的 dist 目录下没有图片，二者 bundle.js 文件中有一个很长的 base64 字符串，打开 index.html 网页也能正常运行。

这是 url-loader 的特点，使用 url-loader 打包图片后，会把图片转化成一个 base64 的字符串后直接放到 bundle.js 中，而不是单独生成一个文件。

这里的问题是，如果图片小且多，可以优化加载速度；但是如果图片很大，那么 js 文件就会变大，让加载变得非常缓慢。

所以最佳实践是同时使用 file-loader 和 url-loader：

```js
module: {
    rules: [{
        test: /\.(png|jpg|gif)$/,
        use: {
            loader: 'url-loader',
            options: {
                name: '[name]_[hash].[ext]',
                outputPath: 'images/',
                limit: 2048
            }
        }
    }]
},
```

上面给 url-loader 加了一个限制，当文件大小小于 2kb（1024 是 1kb）时，就会转化成 base64，否则，就会打包到 `dist/images/` 文件夹中。

## 总结

详细阅读 file-loader 和 url-loader 的文档。

# Loader 打包静态资源（样式）

## 打包 CSS

和上面一样，新建一个样式文件 index.css，然后在 index.js 中导入使用：

```js
import avatar from './avatar.png';
import './index.css';

let img = new Image();
img.src = avatar;
img.classList.add('avatar');

let root = document.getElementById('root');
root.append(img);
```

此时打包会报错，因为 webpack 默认不能识别 css，如果想要打包 css，去 webpack 的官方文档中找对应的 Loader： [style-loader](https://www.webpackjs.com/loaders/style-loader/) 和 [css-loader](https://www.webpackjs.com/loaders/css-loader/)。

修改配置项 webpack.config.js :

```js
module: {
    rules: [
        {
            test: /\.(png|jpg|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name]_[hash].[ext]',
                    outputPath: 'images/',
                    limit: 2048
                }
            }
        },
        {
            test: /\.css$/,
            use: ['style-loader', 'css-loader']
        }
    ]
},
```

我们在上面添加了一条打包规则来打包 css 文件，现在执行命令，正常打包，且 index.html 表现正常。

## style-loader 和 css-loader 的作用

我们重构下代码，兴建一个 avatar.css 文件，里面放 index.css 的内容，index.css 改为引用 avatar.css 的内容：

index.css :

```css
@import './avatar.css';
```

现在打包依然正常，其中的原因就是 `css-loader` 用来分析出几个 css 文件的关系，最终将它们合并成一段 css，`style-loader` 在得到 `css-loader` 生成的内容后，会把这段内容挂载到页面的 header 部分。

![81223488](http://free-en-01.oss.tusy.xyz/2020123/4606-gff3mv.ujbaw.png)

所以我们要让这两个 loader 配合使用。

## 打包 Sass、Less