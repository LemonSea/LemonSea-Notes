# webpack 官网食用指南

webpack API、插件官网就有很多，私人开发的更多，完全记住是不可能的，所以我们的使用方法就是遇到问题的时候要会查文档，要会问前辈。

[Loader 文档](https://www.webpackjs.com/loaders/) 和 [指南](https://www.webpackjs.com/guides/) 是必读的。

[中午文档](https://www.webpackjs.com/concepts/)

[英文文档](https://webpack.js.org/concepts/)

# webpack 打包图片配置

webpack 默认能够打包 js，但是不能打包图片，要打包图片，需要使用插件：`file-loader`，可在官网查看，[webpack 官方文档](https://www.webpackjs.com/loaders/file-loader/)

【安装】

```shell
$ npm install --save-dev file-loader
```

还是上一章的案例，在 `img` 文件夹下放入一个图片，在 `index.js` 导入：

```js
import Header from './header';
import Sidebar from './sidebar';
import Content from './content';
import avater from '../img/png.png';

new Header();
new Sidebar();
new Content();
```

此时执行 `yarn run bundle` 会报错，因为 webpack 默认不能打包图片格式，我们需要自己配置：

webpack.config.js :

```js
const path = require('path')

module.exports = {
    mode: 'development',
    entry: {
    	main: './index.js'
    },
    module: {
        rules: [{
            test: /\.png$/,
            use: {
                loader: 'file-loader'
            }
        }]
    },
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist')
    }
}
```

我们在上面使用一个`file-loader` 插件来打包我们的图片，现在执行打包指令就不会出错 。

![81223485](http://free-en-01.oss.tusy.xyz/2020123/1177-stx90t.13vr.png)

成功后会发现 `dist` 目录下有两个文件，一个是我们的 js 文件打包，一个是我们的图片打包地文件，依然是一个图片。

![81223486](http://free-en-01.oss.tusy.xyz/2020123/4606-fyorgi.grdvl.png)

如果在 `index.js` 中 `console.log(avater)`，执行 `bundle.js` 文件，会输出图片的名字。

# webpack 打包机制

webpack 在打包的时候，默认能够打包 js 文件，当打包到我们链接的图片格式时，webpack 默认无法打包，就会去 webpack.config.js 中寻找帮助，我们在 webpack.config.js 中定义了文件 png 格式打包时使用 file-loader 这个插件，webpack 使用这个插件就能打包图片了。

**file-loader 可以打包很多文件（jpg，txt，excel 等）**

我们之所以知道 webpack 能够用 file-loader 打包图片，是官方文档推荐的，所以官方文档很重要！

# 什么是 loader

loader 就是 webpack 的打包机制，webpack 不知道如何打包时，就回去求助于 loader，以能够正确打包。

# 图片打包初试

调整目录结构，将 index.html 放入 dist 文件夹中（这里是为了打包后能找到图片，如果不这样，在下面的图片地址那里就要做一些修改）

index.js :

```js
import avatar from './png.png';

let img = new Image();
img.src =avatar;

let root = document.getElementById('root');
root.append(img);
```

打开 index.html 文件，可以看到正确显示的图片。

# Loader 打包静态资源（图片）

## file-loader

[file-loader 官方文档](https://www.webpackjs.com/loaders/file-loader/#placeholders)

现在我们打包后，图片名称改变了，如果我们希望图片名字不变，就要做一些配置：

webpack.config.js :

```js
const path = require('path')

module.exports = {
    mode: 'development',
    entry: {
    	main: './src/index.js'
    },
    module: {
        rules: [{
            test: /\.png$/,
            use: {
                loader: 'file-loader',
                options: {
                    // placeholders（占位符）
                    name: '[name].[ext]'
                }
            }
        }]
    },
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist')
    }
}
```

这里我们在 file-loader 配置选项中使用了一个占位符，来规定打包后文件的名字。[官方文档](https://www.webpackjs.com/loaders/file-loader/#placeholders)

除了指定名称外，还可以指定其他的很多东西，如图片打包路径：

```js
options: {
    // placeholders
    name: '[name].[ext]',
        outputPath: 'images/'
}
```

这里规定了图片的输出路径为 `dist/image`。所以，当我们需要配置一些东西的时候，一定要去查看对应的[官方文档](https://www.webpackjs.com/loaders/file-loader/#placeholders)。

## url-loader

[url-loader 官方文档](https://www.webpackjs.com/loaders/url-loader/)

将打包规则替换为 url-loader ：

```js
module: {
    rules: [{
        test: /\.(png|jpg|gif)$/,
        use: {
            loader: 'url-loader',
            options: {
                name: '[name]_[hash].[ext]',
                outputPath: 'images/'
            }
        }
    }]
},
```

执行命令后，会发现打包完成的 dist 目录下没有图片，二者 bundle.js 文件中有一个很长的 base64 字符串，打开 index.html 网页也能正常运行。

这是 url-loader 的特点，使用 url-loader 打包图片后，会把图片转化成一个 base64 的字符串后直接放到 bundle.js 中，而不是单独生成一个文件。

这里的问题是，如果图片小且多，可以优化加载速度；但是如果图片很大，那么 js 文件就会变大，让加载变得非常缓慢。

所以最佳实践是同时使用 file-loader 和 url-loader：

```js
module: {
    rules: [{
        test: /\.(png|jpg|gif)$/,
        use: {
            loader: 'url-loader',
            options: {
                name: '[name]_[hash].[ext]',
                outputPath: 'images/',
                limit: 2048
            }
        }
    }]
},
```

上面给 url-loader 加了一个限制，当文件大小小于 2kb（1024 是 1kb）时，就会转化成 base64，否则，就会打包到 `dist/images/` 文件夹中。

## 总结

详细阅读 file-loader 和 url-loader 的文档。

# Loader 打包静态资源（样式）

## 打包 CSS

和上面一样，新建一个样式文件 index.css，然后在 index.js 中导入使用：

```js
import avatar from './avatar.png';
import './index.css';

let img = new Image();
img.src = avatar;
img.classList.add('avatar');

let root = document.getElementById('root');
root.append(img);
```

此时打包会报错，因为 webpack 默认不能识别 css，如果想要打包 css，去 webpack 的官方文档中找对应的 Loader： [style-loader](https://www.webpackjs.com/loaders/style-loader/) 和 [css-loader](https://www.webpackjs.com/loaders/css-loader/)。

修改配置项 webpack.config.js :

```js
module: {
    rules: [
        {
            test: /\.(png|jpg|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name]_[hash].[ext]',
                    outputPath: 'images/',
                    limit: 2048
                }
            }
        },
        {
            test: /\.css$/,
            use: ['style-loader', 'css-loader']
        }
    ]
},
```

我们在上面添加了一条打包规则来打包 css 文件，现在执行命令，正常打包，且 index.html 表现正常。

## style-loader 和 css-loader 的作用

我们重构下代码，兴建一个 avatar.css 文件，里面放 index.css 的内容，index.css 改为引用 avatar.css 的内容：

index.css :

```css
@import './avatar.css';
```

现在打包依然正常，其中的原因就是 `css-loader` 用来分析出几个 css 文件的关系，最终将它们合并成一段 css，`style-loader` 在得到 `css-loader` 生成的内容后，会把这段内容挂载到页面的 header 部分。

![81223488](http://free-en-01.oss.tusy.xyz/2020123/4606-gff3mv.ujbaw.png)

所以我们要让这两个 loader 配合使用。

## 打包 Sass、Less

把 index.css 转变成 index.sass，恢复里面的内容，index.js 也改为导入 sass 文件。

index.sass :

```scss
body {    
    .avatar {
        width: 150px;
        height: 150px;
        transform: translate(100px, 100px)
    }
}
```

理所当然，使用 Sass 也要按照对应的 loader，但是这里注意不是只按照 sass-loader，还有一个 node-sass，官方文档中有写明，所以在使用 loader 之前，一定要先阅读 [官方文档](https://www.webpackjs.com/loaders/sass-loader/)。

修改 webpack.config.js 添加 scss 打包支持：

```js
{
    test: /\.scss$/,
        use: [{
            loader: "style-loader" // 将 JS 字符串生成为 style 节点
        }, {
            loader: "css-loader" // 将 CSS 转化成 CommonJS 模块
        }, {
            loader: "sass-loader" // 将 Sass 编译成 CSS
        }]
}
```

现在可以正常打包并使用。

## 自动添加厂商前缀的 loader

【postcss-loader】

使用 postcss-loader 来给样式自动添加厂商前缀：[官方文档](https://www.webpackjs.com/loaders/postcss-loader/)

【使用】

根据官方文档的需求，先创建一个 postcss-config.js，这里我们不用官方的内容，而是使用一个插件：`autoprefixer`，安装：

```shell
$ yarn add -D autoprefixer
```

```js
module.exports = {
    plugins: [
        require('autoprefixer')
    ]
}
```

更新 webpack.config.js :

```js
{
    test: /\.scss$/,
        use: [{
            loader: "style-loader" // 将 JS 字符串生成为 style 节点
        }, {
            loader: "css-loader" // 将 CSS 转化成 CommonJS 模块
        }, {
            loader: "sass-loader" // 将 Sass 编译成 CSS
        },
        {
            loader: "postcss-loader"  // 自动添加厂商浅醉
        }]
}
```

上面的配置，当我们发现 scss 文件时，会依次使用 `postcss-loader` `sass-loader` `css-loader` `style-loader`，在 postcss-loader 有一个配置文件，当它被使用时，会进入 psotcss.confing.js 中，使用我们在里面导入的插件 autoprefixer。

现在可以正常打包和显示页面，页面效果也正常，且打开开发者工具，可以看到：![81223489](http://free-en-01.oss.tusy.xyz/2020123/4606-1q1esy0.4wq1.png)

自动多了一个浏览器厂商前缀，这个前缀就是 postcss 里面的 autoprefixer 插件帮我们自动添加的。

## 配置 css-loader

我们新建一个 avatar.scss，然后在 index.scss 中导入：

```scs
@import './avatar.scss';

body {    
    .avatar {
        width: 150px;
        height: 150px;
        transform: translate(100px, 100px)
    }
}
```

在 webpack.config.js 中配置 sass-loader 如下：（这在其他脚手架工具中常见）

```js
{
    test: /\.scss$/,
        use: [{
            loader: "style-loader" // 将 JS 字符串生成为 style 节点
        }, {
            loader: "css-loader", // 将 CSS 转化成 CommonJS 模块
            options: {
                importLoaders: 2 // 0 => 无 loader(默认); 1 => postcss-loader; 2 => postcss-loader, sass-loader
            }
        }, {
            loader: "sass-loader" // 将 Sass 编译成 CSS
        },
              {
                  loader: "postcss-loader"  // 自动添加厂商浅醉
              }]
}
```

如果不加 `importLoader: 2`，webpack 在打包 index.scss 时，其引用的文件就可能不经过 postcss-loader 和 sass-loader，而是直接走 css-loader。

而加上 `importLoader: 2` 的意思就是，通过 import 引入的文件，在打包时也要走前面的两个 loader（这里是 postcss-loader 和 sass-loader），这样会保证无论是 js 中导入 scss 还是在 scss 中导入其他 scss，都会从小向上依次执行所有 loader。

## CSS 模块化打包

我们新建一个 createAvatar.js 文件，里面的内容是：

```js
import avatar from './avatar.png';

function createAvatar() {
    let img = new Image();
    img.src = avatar;
    img.classList.add('avatar');

    let root = document.getElementById('root');
    root.append(img);
}

export default createAvatar;
```

更改 index.js 为：

```js
import avatar from './avatar.png';
import './index.scss';
import createAvatar from './createAvatar';

createAvatar()

let img = new Image();
img.src = avatar;
img.classList.add('avatar');

let root = document.getElementById('root');
root.append(img);
```

现在我们想的是，页面会有两张图片。打包执行显示，页面确实有两张图片，但两张图片的样式是一样的：

![81223490](http://free-en-01.oss.tusy.xyz/2020123/4606-oyj18d.x14te.png)

也就是说，在 index.js 中导入的样式，会影响其他模块的样式，相当于样式是全局的，这样很容易出现样式冲突的问题。我们期待的是**模块化的 css**，即一个模块中的样式只作用于这个模块。

我们可以在 webpack.config.js 中开启 css 模块化打包：

```js
{
    loader: "css-loader", // 将 CSS 转化成 CommonJS 模块
        options: {
            importLoaders: 2, // 0 => 无 loader(默认); 1 => postcss-loader; 2 => postcss-loader, sass-loader
                modules: true  // 启用 CSS 模块
        }
}
```

现在去修改 index.js 中的代码：

```js
import avatar from './avatar.png';
import style from './index.scss';
import createAvatar from './createAvatar';

createAvatar()

let img = new Image();
img.src = avatar;
img.classList.add(style.avatar);

let root = document.getElementById('root');
root.append(img);
```

上面把全局引用改为了局部引用 index.css，这样就完成了 css 的模块化打包了。

<img src="http://free-en-01.oss.tusy.xyz/2020123/4606-ytnmk4.jjgqo.png" alt="81223491" style="zoom: 50%;" />

## 打包字体文件

打包字体，使用 `file-loader` 即可，方法于上网图片相同。

## 注意

webpack 中，loader 的执行是有顺序的：从下到上，从右到左，所以要注意 loader 使用的顺序。

关于资源的打包可以参考 [webpack 指南中的资源管理（Asset Management）](https://www.webpackjs.com/guides/asset-management/)

# 使用 plugins 加快打包速度

plugins 就是插件的意思 

## HTML文件自生成插件（HtmlWebpackPlugin）

### 使用 HtmlWebpackPlugin 

安装：

```shell
npm install --save-dev html-webpack-plugin
```

使用方法：

在 webpack.config.js 中导入，然后进行配置：

```js
var HtmlWebpackPlugin = require('html-webpack-plugin');
var path = require('path');

var webpackConfig = {
  entry: 'index.js',
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'index_bundle.js'
  },
  plugins: [new HtmlWebpackPlugin()]
};
```

（上面的官网配置，核心就是把 `plugins: [new HtmlWebpackPlugin()]` 加到我们的配置文件中。

配置完成后，我们删除 dist 目录进行打包（index.html 在该目录下），打包成功后会看见 dist 目录下不但有 bundle.js，还有 index.html 文件：

![81223493](http://free-en-01.oss.tusy.xyz/2020123/1177-11gyefh.4ivi.png)

### 配置 HtmlWebpackPlugin 

HtmlWebpackPlugin 这个插件会在打包结束后，自动生成一个文件，并把打包生成的 js 自动引入该文件中。

但是现在实际上打开页面是无效的，因为我们的 js 代码需要 `<div class='root' ></div>`，但是生成的 html 中没有这个 div。

 我们可以对插件进行配置，HtmlWebpackPlugin 能接收一个模板文件，我们写一个含有 `<div class='root' ></div>` 的模板 html（就是普通的 html），传递给 template ：

```js
plugins: [new HtmlWebpackPlugin({
    template: 'src/index.html'
})],
```

此时再打包生成的 html 文件中就有 `<div class='root' ></div>`，原因是 HtmlWebpackPlugin 会使用它们提供的 html 为模板，将打包后的 bundle.js 文件注入 html 模板中生成新模板。

## 旧文件删除插件（clean-webpack-plugin）

[clean-webpack-plugin](https://github.com/johnagan/clean-webpack-plugin) 这个插件可以帮助我们在每次重打包后删除以前的打包文件。

### 使用 clean-webpack-plugin

使用方法也是先导入，然后在 webpack.config.js 文件的 plugin 项中配置：

```js
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
```

```js
plugins: [
    new CleanWebpackPlugin({
        cleanAfterEveryBuildPatterns: ['dist']
    })
]
```

plugins 是一个数组，我们直接写在 HtmlWebpackPlugin 后面，配置的内容就是在打包前，这个插件会帮助我们删除 dist 目录下的所有内容。

使用的是 3.0.3 版本，此版本必须这样才不会报错。

## 总结

plugin 插件的作用就是在 webpack 执行到某一阶段的时候，帮我们完成某些事情（类似生命周期函数）。

每个 plugin 作用的时间不同，HtmlWebpackPlugin 的作用时间是打包完成的时候，CleanWebpackPlugin 的作用时间是打包前。

# Entry 和 OutPut 配置

我们前面定义的打包设置是：

```js
entry: {
    main: './src/index.js'
}
```

上面只打包一个文件，所有可以按照下面的写法配置输出 :

```js
output: {
    filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist')
},
```

但是，如果我们打包多文件的话：

```js
entry: {
        main: './src/index.js',
        sub: './src/index.js'
}
```

